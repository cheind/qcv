#summary A Five Minute Tutorial
#sidebar TableOfContents

<wiki:toc max_depth="3" />

=What is QCV?=

QCV is an acronym and stands for "Quick Computer Vision". QCV is a framework for rapid development of computer vision algorithms. It is split into the following parts
  # an application (qcv.exe) to host and run your algorithms,
  # a class library (QCV.Toolbox.dll) containing commonly used algorithms,
  # a class library (QCV.Base.dll) representing the core entities QCV and
  # Third-party libraries (such as Emgu/OpenCV) providing additional data structures and algorithms.

=Motivation=
Does the following paragraph sound familiar to you?
 Have you ever had a great idea for an algorithm but failed to implement it because setting up the environment took to much time? Have you ever felt frustrated setting up projects, managing dependencies, closing your application for a rebuilt to see the effects of your changed algorithm?

Sounds familiar? Then QCV is for you. It provides a complete setup to host and run your algorithms. You don't even need a integrated development environment to get started. QCV automatically detects changes in your algorithm source files and applies those changes online.

=Installation=

In order to run QCV you need to install
 * Install the Microsoft .Net Framework 3.5 Service Pack 1
 * Install the Microsoft Visual C++ 2008 Redistributable Package (x86) Service Pack 1
 * QCV

=How does QCV work?=

==Class Library==
Simply speaking, QCV processes a list of objects in a loop until a stopping criterium is met. 

These objects are termed filters and have to implement the <tt>QCV.Base.IFilter</tt> interface. The chronological order of filters is determined by their absolute position in an instance of <tt>QCV.Base.FilterList</tt>. Classes that support creating of filter lists have to implement <tt>QCV.Base.IFilterListProvider</tt>.

Such list of filters can then be passed to <tt>QCV.Base.Runtime</tt> to process the filters asynchronously. The runtime invokes each filter and passes a so called bundle, an open dictionary of objects, containing parameters for the filter. 

The filter can read from and write to this bundle to communicate with other filters in the current filter list. To interact with the user, an instance of <tt>QCV.Base.IDataInteractor</tt> is contained in the filters bundle. 

The data interactor allows the filter to
  * expose events,
  * show values and images to the user,
  * query values from the user.

The runtime stops processing of the filter list if one of the following conditions are met
  * a filter requests the stop,
  * a user requests stops the runtime, or
  * an exception occurred while processing one of the filters.

QCV makes heavy use of plugins, termed addins in QCV. Any class carrying the <tt>QCV.Base.Addins.AddinAttribute</tt> is considered an addin. QCV can detects plugins in loaded assemblies, assemblies stored at disk, and assemblies generated on-the-fly by compiling code. 

Addins are collected in instances of <tt>QCV.Base.Addins.AddinHost</tt>. The host supports addin queries and is responsible for creating addins. All filters should be addins, so that they can be created by filter list providers implemented as addin. 

==QCV - Application==
QCV provides a graphical user interface application for hosting and running filters that is started by 
{{{
qcv.exe
}}}

The following image annotates parts of <tt>qcv.exe</tt>. Don't worry if you don't understand all the annotations at this point of the tutorial.

http://qcv.googlecode.com/svn/trunk/etc/doc/qcv-callouts.png

The remaining part of this tutorial will make heavy use of <tt>qcv.exe</tt> to illustrate previously described concepts.

=Hello World=

The famous HelloWorld in QCV.

{{{
using System;
using System.Collections.Generic;

using QCV.Base;
using QCV.Base.Addins;

namespace Tutorial {

  [Addin]
  public class HelloWorld : IFilter, IFilterListProvider {
    
    // Create a new FilterList containing a single HelloWorld filter.
    public FilterList CreateFilterList(AddinHost host) {
      return new FilterList() {
        this
      };
    }
    
    // Execute filter
    public void Execute(Dictionary<string, object> bundle) {
      System.Console.WriteLine("Hello World!");
      bundle["cancel"] = true;
    }
    
  }
}
}}}

Run the example by saving the code to <tt>hello_world.cs</tt> and typing
{{{
qcv.exe -s hello_world.cs Tutorial.HelloWorld
}}}
in your command line. This will tell <tt>qcv.exe</tt> to load and compile <tt>hello_world.cs</tt> and use instances of <tt>Tutorial.HelloWorld</tt> as provider for filter lists.

Next press 'Run' to start processing the filter list. The runtime will invoke each filter in the list as retrieved by calling <tt>Tutorial.HelloWorld.CreateFilterList</tt>. In our case the filter list is composed of a single filter that will print a message and use the bundle parameter to request a stop of the runtime.

|| *Tip* <tt>qcv.exe</tt> automatically compiles all sources passed by the <tt>-s</tt> command line switch and makes them available for usage. Whether compilation succeeds or failed can be seen in the 'Console'. <tt>qcv.exe</tt> detects file modifications of all sources. In case a change is detected all sources are recompiled and on success, existing objects are replaced with instances of their new types.||

|| *Tip* To execute the filter list immediately after starting <tt>qcv.exe</tt> supply the <tt>--run</tt> argument.||

=Getting Image Input=

The following shows how to retrieve images from a camera source.

{{{
// qcv.exe -s camera_input.cs Tutorial.CameraInput --run

using System;
using System.Collections.Generic;

using QCV.Base;
using QCV.Base.Addins;

namespace Tutorial {

  [Addin]
  public class CameraInput : IFilterListProvider {
    
    // Create a new FilterList containing a camera filter
    public FilterList CreateFilterList(AddinHost host) {
      
      QCV.Toolbox.Camera c = new QCV.Toolbox.Camera();
      c.DeviceIndex = 0;
      c.Name = "source";
      
      return new FilterList() {c};
    }

  }
}
}}}

A filter of type <tt>QCV.Toolbox.Camera</tt> connects to a camera specified by its <tt>Camera.DeviceIndex</tt>. The <tt>Camera.Name</tt> property specifies the name of the key used to place the image in the bundle.

QCV ships with support for the following image input sources
  * <tt>QCV.Toolbox.Camera</tt> - Images from a Video-For-Windows camera device.
  * <tt>QCV.Toolbox.Video</tt> -  Images from a video stored at disk.
  * <tt>QCV.Toolbox.ImageList</tt> - Images from a collection of images stored at disk.

|| *Tip* You can read and modify the properties of filters by selecting the filter from the dropdown box in <tt>qcv.exe</tt>.||

=Image Input from Multiple Sources=

You can, of course, connect from multiple sources within a single filter list.

{{{
// qcv.exe -s multiple_image_input.cs Tutorial.MultipleImageInput --run

using System;
using System.Collections.Generic;

using QCV.Base;
using QCV.Base.Addins;

namespace Tutorial {

  [Addin]
  public class MultipleImageInput : IFilterListProvider {
    
    // Create a new FilterList containing multiple image sources
    public FilterList CreateFilterList(AddinHost host) {
      
      return new FilterList() {
        // Camera with requested frame dimensions
        new QCV.Toolbox.Camera(0, 320, 200, "camera"),
        // Video from disk - looping enabled
        new QCV.Toolbox.Video("../../etc/videos/a.avi", "video", true),
        // Image list from disk - looping enabled
        new QCV.Toolbox.ImageList("../../etc/images", "*.png", "images", true)
      };
      
    }
    
  }
}
}}}

Note that, the video and image list source is set into looping mode. Otherwise, they would request the runtime to stop if the video has ended or all images from disk have been displayed.

=Displaying Images=

The following example shows how-to use <tt>QCV.Base.IDataInteractor</tt> to display images.

{{{
// qcv.exe -s displaying_images.cs Tutorial.DisplayingImages --run

using System;
using System.Collections.Generic;

using QCV.Base;
using QCV.Base.Addins;
using QCV.Base.Extensions; // ease access of bundle

// Image types are Emgu types
using Emgu.CV;
using Emgu.CV.Structure;

namespace Tutorial {

  [Addin]
  public class DisplayingImages : IFilter, IFilterListProvider {
    
    public FilterList CreateFilterList(AddinHost host) {
      
      return new FilterList() {
        // Camera with requested frame dimensions
        new QCV.Toolbox.Camera(0, 320, 200, "camera"),
        // Display
        this
      };
      
    }
    
    public void Execute(Dictionary<string, object> bundle) {
      // Fetch the interactor from the bundle
      IDataInteractor idi = bundle.FetchInteractor();
      // Fetch the current image from camera
      Image<Bgr, byte> image = bundle.FetchImage("camera");
      // Request showing the image.
      idi.Show("camera live feed", image);
    }
    
  }
}
}}}


=Displaying Variables=

The following example shows how-to use <tt>QCV.Base.IDataInteractor</tt> to display values of variables that are not images.

{{{
// qcv.exe -s displaying_values.cs Tutorial.DisplayingValues --run

using System;
using System.Collections.Generic;
using System.Diagnostics;

using QCV.Base;
using QCV.Base.Addins;
using QCV.Base.Extensions;

namespace Tutorial {

  [Addin]
  public class DisplayingValues : IFilter, IFilterListProvider {
    // Stopwatch to measure elapsed time between calls
    private Stopwatch _sw = new Stopwatch();
    
    public FilterList CreateFilterList(AddinHost host) {
      return new FilterList() {
        // Display FPS
        this
      };
    }
    
    public void Execute(Dictionary<string, object> bundle) {
      if (_sw.IsRunning) {
        _sw.Stop();
        IDataInteractor idi = bundle.FetchInteractor();
        idi.Show("DisplayingValues.FPS", 1.0 / _sw.Elapsed.TotalSeconds);
        _sw.Reset();
      }
      _sw.Start();      
    }
    
  }
}
}}}

Similar to [Tutorial#Displaying_Images] we use the <tt>QCV.Base.IDataInteractor</tt> interface to show arbitrary values. In this example, the number of frames per second is calculated and shown at each invocation of the <tt>Tutorial.DisplayingValues</tt> filter.

Try playing around with the FPS setting in the graphical user interface and notice how <tt>qcv.exe</tt> comes close to achieving the desired frame rate.

|| *Tip* You might want to use <tt>QCV.Toolbox.ShowFPS</tt> because it reduces the stress on <tt>qcv.exe</tt> by definining a frequency for updating the frame rate value.||

|| *Tip* You can pass a predefined FPS value via the commandline by specifying <tt>--fps=VALUE</tt> or disabling cycle time control by supplying <tt>--nofps</tt>. Alternatively you can adjust the FPS setting via the graphical user interface.||

=Displaying Properties=
Any public readable property exposed by a filter is by default shown in property section of <tt>qcv.exe</tt>. Writable properties can be modified by the user. Here's a sample illustrating usage of properties.

{{{
// qcv.exe -s properties.cs Tutorial.Properties --run

using System;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics;

using QCV.Base;
using QCV.Base.Addins;
using QCV.Base.Extensions;

namespace Tutorial {

  [Addin]
  public class Properties : IFilter, IFilterListProvider {
    
    public FilterList CreateFilterList(AddinHost host) {
      return new FilterList() {
        this
      };
    }
    
    private string _name = "John Doe";
    [Description("This specifies your name used for accounting.")]
    public string Name {
      get { return _name; }
      set {_name = value; }
    }
    
    private int _id = 10;
    [Description("This is your unique identifier as generated by the system.")]
    [ReadOnly(true)]
    public int Id {
      get { return _id; }
      set {_id = value; }
    }
    
    private int _hidden = 10;
    [Description("This property won't show up.")]
    [Browsable(false)]
    public int Hidden {
      get { return _hidden; }
      set {_hidden = value; }
    }
    
    public void Execute(Dictionary<string, object> bundle) 
    {}
    
  }
}
}}}

Note that changing properties is asynchronous event. QCV currently reflects any change to a property directly to the instance of the object. Therefore you might need to synchronize access to the property yourself. In future versions of QCV property changes will be cached and executed when the filter asks for it (see [Tutorial#Event_Notifications] for details.

|| *Tip* <tt>qcv.exe</tt> uses <tt>System.Windows.Forms.PropertyGrid</tt> to show properties of the selected filter. As such, it supports all attributes that are known and processed by the <tt>PropertyGrid</tt> class. Consult the <tt>PropertyGrid</tt> documentation for details.||

=Event Notifications=

Events are one way for the user to interact with your filters. Events are asynchronous notifications with no parameters. <tt>qcv.exe</tt> renders them as buttons in the event section of the selected filter. Because of its asynchronous nature, QCV provides a thread-safe method to handle them in your filter.

The following example defines an <tt>OnPrintGreeting</tt> event.

{{{
// qcv.exe -s event_notifications.cs Tutorial.EventNotifications --run

using System;
using System.Collections.Generic;
using System.Diagnostics;

using QCV.Base;
using QCV.Base.Addins;
using QCV.Base.Extensions;

namespace Tutorial {

  [Addin]
  public class EventNotifications : IFilter, IFilterListProvider {
    
    public FilterList CreateFilterList(AddinHost host) {
      return new FilterList() {
        this
      };
    }
    
    public void OnPrintGreeting(Dictionary<string, object> bundle) {
      Console.WriteLine("Hello EventNotifications!");
    }
    
    public void Execute(Dictionary<string, object> bundle) {
      IDataInteractor idi = bundle.FetchInteractor();
      // Process all pending events, supplying them with the current bundle information
      idi.ExecutePendingEvents(this, bundle);
    }
    
  }
}
}}}


=Querying Variables=

Besides event notifications, a filter can query the user for immediate input. Querying values this way will stop the filter list until the user has answered the query.

The following example extends the example from [Tutorial#Event_Notifications] by querying for a name to greet once the event has been triggered.

{{{
// qcv.exe -s variable_query.cs Tutorial.VariableQuery --run

using System;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics;

using QCV.Base;
using QCV.Base.Addins;
using QCV.Base.Extensions;

namespace Tutorial {

  [Addin]
  public class VariableQuery : IFilter, IFilterListProvider {
    
    // User will be queried to complete the values in this struct
    class Name {
      string _first_name = "John";
      string _last_name = "Doe";
      
      [Description("Your first name")]
      public String FirstName {
        get { return _first_name; }
        set { _first_name = value; }
      }
      
      [Description("Your last name")]
      public String LastName {
        get { return _last_name; }
        set { _last_name = value; }
      }
    };
    
    public FilterList CreateFilterList(AddinHost host) {
      return new FilterList() {
        this
      };
    }
    
    public void OnPrintGreeting(Dictionary<string, object> bundle) {
      IDataInteractor idi = bundle.FetchInteractor();
      Name n = new Name();
      
      if (idi.Query("What's your name?", n)) {
        // User positively responded to our query
        Console.WriteLine(String.Format("Hello {0} {1}", n.FirstName, n.LastName));
      } 
      
    }
    
    public void Execute(Dictionary<string, object> bundle) {
      IDataInteractor idi = bundle.FetchInteractor();
      // Process all pending events, supplying them with the current bundle information
      idi.ExecutePendingEvents(this, bundle);
    }
    
  }
}
}}}


=Advanced Usage=
==Saving and Loading State==
==Exceptions==
==Debugging==
==Commandline Arguments==