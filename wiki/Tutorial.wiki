#summary A Five Minute Tutorial

<wiki:toc max_depth="3" />

=What is QCV?=

QCV is an acronym and stands for "Quick Computer Vision". QCV is a framework for rapid development of computer vision algorithms. It is split into the following parts
  # an application (qcv.exe) to host and run your algorithms,
  # a class library (QCV.Toolbox.dll) containing commonly used algorithms,
  # a class library (QCV.Base.dll) representing the core entities QCV and
  # Third-party libraries (such as Emgu/OpenCV) providing additional data structures and algorithms.

=Motivation=
Does the following paragraph sound familiar to you?
 Have you ever had a great idea for an algorithm but failed to implement it because setting up the environment took to much time? Have you ever felt frustrated setting up projects, managing dependencies, closing your application for a rebuilt to see the effects of your changed algorithm?

Sounds familiar? Then QCV is for you. It provides a complete setup to host and run your algorithms. You don't even need a integrated development environment to get started. QCV automatically detects changes in your algorithm source files and applies those changes online.

=Installation=

In order to run QCV you need to install
 * Install the Microsoft .Net Framework 3.5 Service Pack 1
 * Install the Microsoft Visual C++ 2008 Redistributable Package (x86) Service Pack 1
 * QCV

=How does QCV work?=
Simply speaking, QCV processes a list of objects in a loop until one of the stopping criteria are met. 

These objects are termed filters and have to implement the <tt>QCV.Base.IFilter</tt> interface. The chronological order of filters is determined by their absolute position in an instance of <tt>QCV.Base.FilterList</tt>. 

Such list of filters can then be passed to <tt>QCV.Base.Runtime</tt> to process the filters asynchronously. The runtime invokes each filter and passes a so called bundle, an open dictionary of objects, containing parameters for the filter. 

The filter can read from and write to this bundle to communicate with other filters in the current filter list. To interact with the user, an instance of <tt>QCV.Base.IDataInteractor</tt> is contained in the filters bundle. 

The data interactor allows the filter to
  * expose events,
  * show values and images to the user,
  * query values from the user.

The runtime stops processing of the filter list if one of the following conditions are met
  * a filter requests the stop,
  * a user requests stops the runtime, or
  * an exception occurred while processing one of the filters.

==Hello World==

{{{
using System;
using System.Collections.Generic;

using QCV.Base;
using QCV.Base.Addins;

namespace Tutorial {

  [Addin]
  public class HelloWorld : IFilter, IFilterListProvider {
    
    // Create a new FilterList containing a single HelloWorld filter.
    public FilterList CreateFilterList(AddinHost host) {
      return new FilterList() {
        this
      };
    }
    
    // Execute filter
    public void Execute(Dictionary<string, object> bundle) {
      System.Console.WriteLine("Hello World!");
      bundle["cancel"] = true;
    }
    
  }
}
}}}

You can run the above example by saving it to <tt>hello_world.cs</tt> and then invoke
{{{
qcv.exe -s hello_world.cs Tutorial.HelloWorld
}}}
on your command line. This will tell <tt>qcv.exe</tt> to load and compile <tt>hello_world.cs</tt> and use instances of <tt>Tutorial.HelloWorld</tt> as provider for filter lists.




This will startup <tt>qcv.exe</tt> which will display a graphical user interface allowing you to interact with hosted filters. The following image annotates parts of <tt>qcv.exe</tt>. Don't worry if you don't understand all the annotations at this point of the tutorial.

http://qcv.googlecode.com/svn/trunk/etc/doc/qcv-callouts.png

As in our example, <tt>qcv.exe</tt> automatically compiles all sources passed by the <tt>-s</tt> command line switch and makes them available for usage. Whether compilation succeeds or failed can be seen from the Console section. <tt>qcv.exe</tt> additionally detects file modifications of all registered scripts. In case a change is detected all sources are recompiled and on success, existing objects are replaced with instances of their new types.



==Getting Input from Sources==
==Interaction==
===Displaying Images===
===Displaying Variables===
===Querying Variables===
===Event Notifications===

=Advanced Usage=
==Saving and Loading State==
==Exceptions==
==Debugging==
==Commandline Arguments==