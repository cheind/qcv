#summary A Five Minute Tutorial
#sidebar TableOfContents

<wiki:toc max_depth="3" />

=What is QCV?=

QCV is an acronym and stands for "Quick Computer Vision". QCV is a framework for rapid development of computer vision algorithms. It is split into the following parts
  # an application (qcv.exe) to host and run your algorithms,
  # a class library (QCV.Toolbox.dll) containing commonly used algorithms,
  # a class library (QCV.Base.dll) representing the core entities QCV and
  # Third-party libraries (such as Emgu/OpenCV) providing additional data structures and algorithms.

=Motivation=
Does the following paragraph sound familiar to you?
 Have you ever had a great idea for an algorithm but failed to implement it because setting up the environment took to much time? Have you ever felt frustrated setting up projects, managing dependencies, closing your application for a rebuilt to see the effects of your changed algorithm?

Sounds familiar? Then QCV is for you. It provides a complete setup to host and run your algorithms. You don't even need a integrated development environment to get started. QCV automatically detects changes in your algorithm source files and applies those changes online.

=Installation=

In order to run QCV you need to install
 * Install the Microsoft .Net Framework 3.5 Service Pack 1
 * Install the Microsoft Visual C++ 2008 Redistributable Package (x86) Service Pack 1
 * QCV

=How does QCV work?=

==Class Library==
Simply speaking, QCV processes a list of objects in a loop until a stopping criterium is met. 

These objects are termed filters and have to implement the <tt>QCV.Base.IFilter</tt> interface. The chronological order of filters is determined by their absolute position in an instance of <tt>QCV.Base.FilterList</tt>. Classes that support creating of filter lists have to implement <tt>QCV.Base.IFilterListProvider</tt>.

Such list of filters can then be passed to <tt>QCV.Base.Runtime</tt> to process the filters asynchronously. The runtime invokes each filter and passes a so called bundle, an open dictionary of objects, containing parameters for the filter. 

The filter can read from and write to this bundle to communicate with other filters in the current filter list. To interact with the user, an instance of <tt>QCV.Base.IDataInteractor</tt> is contained in the filters bundle. 

The data interactor allows the filter to
  * expose events,
  * show values and images to the user,
  * query values from the user.

The runtime stops processing of the filter list if one of the following conditions are met
  * a filter requests the stop,
  * a user requests stops the runtime, or
  * an exception occurred while processing one of the filters.

QCV makes heavy use of plugins, termed addins in QCV. Any class carrying the <tt>QCV.Base.Addins.AddinAttribute</tt> is considered an addin. QCV can detects plugins in loaded assemblies, assemblies stored at disk, and assemblies generated on-the-fly by compiling code. 

Addins are collected in instances of <tt>QCV.Base.Addins.AddinHost</tt>. The host supports addin queries and is responsible for creating addins. All filters should be addins, so that they can be created by filter list providers implemented as addin. 

==QCV - Application==
QCV provides a graphical user interface application for hosting and running filters that is started by 
{{{
qcv.exe
}}}

The following image annotates parts of <tt>qcv.exe</tt>. Don't worry if you don't understand all the annotations at this point of the tutorial.

http://qcv.googlecode.com/svn/trunk/etc/doc/qcv-callouts.png

The remaining part of this tutorial will make heavy use of <tt>qcv.exe</tt> to illustrate previously described concepts.

=Hello World=

The famous HelloWorld in QCV.

{{{
using System;
using System.Collections.Generic;

using QCV.Base;
using QCV.Base.Addins;

namespace Tutorial {

  [Addin]
  public class HelloWorld : IFilter, IFilterListProvider {
    
    // Create a new FilterList containing a single HelloWorld filter.
    public FilterList CreateFilterList(AddinHost host) {
      return new FilterList() {
        this
      };
    }
    
    // Execute filter
    public void Execute(Dictionary<string, object> bundle) {
      System.Console.WriteLine("Hello World!");
      bundle["cancel"] = true;
    }
    
  }
}
}}}

Run the example by saving the code to <tt>hello_world.cs</tt> and typing
{{{
qcv.exe -s hello_world.cs Tutorial.HelloWorld
}}}
in your command line. This will tell <tt>qcv.exe</tt> to load and compile <tt>hello_world.cs</tt> and use instances of <tt>Tutorial.HelloWorld</tt> as provider for filter lists.

Next press 'Run' to start processing the filter list. The runtime will invoke each filter in the list as retrieved by calling <tt>Tutorial.HelloWorld.CreateFilterList</tt>. In our case the filter list is composed of a single filter that will print a message and use the bundle parameter to request a stop of the runtime.

Note that, <tt>qcv.exe</tt> automatically compiles all sources passed by the <tt>-s</tt> command line switch and makes them available for usage. Whether compilation succeeds or failed can be seen in the 'Console'. <tt>qcv.exe</tt> detects file modifications of all sources. In case a change is detected all sources are recompiled and on success, existing objects are replaced with instances of their new types.

=Getting Image Input=

The following shows how to retrieve images from a camera source.

{{{
// qcv.exe -s camera_input.cs Tutorial.CameraInput

using System;
using System.Collections.Generic;

using QCV.Base;
using QCV.Base.Addins;

namespace Tutorial {

  [Addin]
  public class CameraInput : IFilterListProvider {
    
    // Create a new FilterList containing a camera filter
    public FilterList CreateFilterList(AddinHost host) {
      
      QCV.Toolbox.Camera c = new QCV.Toolbox.Camera();
      c.DeviceIndex = 0;
      c.Name = "source";
      
      return new FilterList() {c};
    }

  }
}
}}}

A filter of type <tt>QCV.Toolbox.Camera</tt> connects to a camera specified by its <tt>Camera.DeviceIndex</tt>. The <tt>Camera.Name</tt> property specifies the name of the key used to place the image in the bundle.

QCV ships with support for the following image input sources
  * <tt>QCV.Toolbox.Camera</tt> - Images from a Video-For-Windows camera device.
  * <tt>QCV.Toolbox.Video</tt> -  Images from a video stored at disk.
  * <tt>QCV.Toolbox.ImageList</tt> - Images from a collection of images stored at disk.

You can, of course, connect from multiple sources within a single filter list.

{{{
// qcv.exe -s multiple_image_input.cs Tutorial.MultipleImageInput

using System;
using System.Collections.Generic;

using QCV.Base;
using QCV.Base.Addins;

namespace Tutorial {

  [Addin]
  public class MultipleImageInput : IFilterListProvider {
    
    // Create a new FilterList containing multiple image sources
    public FilterList CreateFilterList(AddinHost host) {
      
      return new FilterList() {
        // Camera with requested frame dimensions
        new QCV.Toolbox.Camera(0, 320, 200, "camera"),
        // Video from disk - looping enabled
        new QCV.Toolbox.Video("../../etc/videos/a.avi", "video", true),
        // Image list from disk - looping enabled
        new QCV.Toolbox.ImageList("../../etc/images", "*.png", "images", true)
      };
      
    }
    
  }
}
}}}

Note that, the video and image list source is set into looping mode. Otherwise, they would request the runtime to stop if the video has ended or all images from disk have been displayed.

==Interaction==
===Displaying Images===
===Displaying Variables===
===Querying Variables===
===Event Notifications===

=Advanced Usage=
==Saving and Loading State==
==Exceptions==
==Debugging==
==Commandline Arguments==